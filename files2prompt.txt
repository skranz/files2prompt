Below are relevant files from my R project.

################################################
# R project DESCRIPTION file:
################################################

```
Package: files2prompt
Type: Package
Title: RStudio addin to create prompt from code or text files in a project directory
Version: 0.1.0
Author: Sebastian Kranz
Maintainer: Sebastian Kranz <sebastian.kranz@uni-ulm.de>
Description: Can be customized using TOML based specifications.
License: MIT
Encoding: UTF-8
LazyData: true
Imports:
    restorepoint,
    stringi,
    RcppTOML
Suggests:
    rstudioapi,
    clipr
RoxygenNote: 7.2.3
```


################################################
# R code files:
################################################


# FILE: addin.R
```
#' @keywords internal
generate_prompt_addin <- function() {
  restore.point("addin_find_config_toml")
  library(files2prompt)
  if (!requireNamespace("rstudioapi", quietly = TRUE)) {
    stop("The add-in requires the {rstudioapi} package.")
  }

  # 1. Is RStudio running a project?
  if (!rstudioapi::isAvailable("1.1.287")) {
    stop("This add-in only works inside RStudio 1.1 or newer.")
  }

  # 2. Locate TOML (default file name)
  config_file = addin_find_config_toml()
  if (!file.exists(config_file)) {
    stop("No config_file found... that is strange.")
  }

  # 3. Determine root_dir
  proj <- tryCatch(rstudioapi::getActiveProject(), error = function(e) NULL)
  if (!is.null(proj) && dir.exists(proj)) {
    root_dir = proj
  } else {
    root_dir = getwd()
  }

  # 4. Build prompt
  prompt <- files2prompt(config_file)

  # 4. Save & copy
  outfile <- file.path(root_dir, "files2prompt.txt")
  writeLines(prompt, outfile)
  cat("\nPrompt written to ", outfile,"")

  if (requireNamespace("clipr", quietly = TRUE)) {
    clipr::write_clip(prompt)
    cat("and copied to clipboard.")
  }
  cat("\nEstimated token count: ", guess_token_num(prompt),"\n")


   # Open the file
  rstudioapi::navigateToFile(outfile)

  ## --- NEW: select the whole document --------------------------------------
  ctx <- rstudioapi::getSourceEditorContext()
  if (normalizePath(ctx$path, winslash = "/") ==
      normalizePath(outfile, winslash = "/")) {
    last_line <- length(ctx$contents)
    rng <- rstudioapi::document_range(
             rstudioapi::document_position(1, 0),
             rstudioapi::document_position(
               last_line, nchar(ctx$contents[last_line]))
           )
    rstudioapi::setSelectionRanges(id = ctx$id, ranges = list(rng))
  }
  invisible(prompt)
}

addin_find_config_toml <- function() {
  restore.point("addin_find_config_toml")
  is_toml <- function(path) length(path) == 1L &&
                             is.character(path)  &&
                             file.exists(path)   &&
                             grepl("\\.toml$", path, ignore.case = TRUE)

  ## 1 — active editor file ---------------------------------------------------
  if (rstudioapi::isAvailable("1.1.287")) {
    ctx <- tryCatch(rstudioapi::getSourceEditorContext(),
                    error = function(e) NULL)
    if (!is.null(ctx$path) && nzchar(ctx$path) && is_toml(ctx$path))
      return(normalizePath(ctx$path, winslash = "/"))
  }

  ## 2 — explicit option ------------------------------------------------------
  opt <- getOption("file2prompt")
  if (is.list(opt) && is_toml(opt$toml_file))
    return(normalizePath(opt$toml_file, winslash = "/"))

  ## 3 — dir from option ------------------------------------------------------
  if (is.list(opt) && !is.null(opt$dir) && dir.exists(opt$dir)) {
    tomls <- sort(list.files(opt$dir, pattern = ".*f2p.*\\.toml$", full.names = TRUE))
    if (length(tomls)) return(normalizePath(tomls[1], winslash = "/"))
  }

  ## 4 — project root ---------------------------------------------------------
  proj <- tryCatch(rstudioapi::getActiveProject(), error = function(e) NULL)
  if (!is.null(proj) && dir.exists(proj)) {
    tomls <- sort(list.files(proj, pattern = ".*f2p.*\\.toml$", full.names = TRUE))
    if (length(tomls)) return(normalizePath(tomls[1], winslash = "/"))
  }

  ## 5 — working directory ---------------------------------------------------------
  wd <- getwd()
  if (!is.null(wd) && dir.exists(wd)) {
    tomls <- sort(list.files(wd, pattern = ".*f2p.*\\.toml$", full.names = TRUE))
    if (length(tomls)) return(normalizePath(tomls[1], winslash = "/"))
  }


  ## 6 — fallback for R packages ---------------------------------------------
  if (!is.null(proj) && file.exists(file.path(proj, "DESCRIPTION"))) {
    pkg_tpl <- system.file("toml/f2p_r_pkg.toml",
                           package = "files2prompt", mustWork = FALSE)
    if (nzchar(pkg_tpl) && file.exists(pkg_tpl))
      return(pkg_tpl)
  }

  ## 7 — generic default ------------------------------------------------------
  def_tpl <- system.file("toml/f2p_default.toml",
                         package = "files2prompt", mustWork = FALSE)
  if (nzchar(def_tpl) && file.exists(def_tpl))
    return(def_tpl)

  stop("No TOML specification file could be located.")
}
```
# END OF FILE: addin.R

-----------------------------------------------------------


# FILE: f2p.R
```
example = function() {
  config_file = "rproject_spec.toml"
  prompt = files2prompt(config_file)
  options(warn=2)
  writeLines(prompt, "C:/libraries/files2prompt/prompt.txt")
  cat(main_prompt)
  guess_token_num(main_prompt)
}

#' Build a prompt from text files
#'
#' Reads a TOML specification in the
#' collects the matching files and returns the assembled prompt
#' that can be parsed to a LLM
#'
#' @param config_file Path to the TOML config file.
#' @param root_dir    Override the `root_dir` declared in the TOML.
#'                    Use `NULL` (default) to respect the spec.
#' @param open,close  Delimiters used in templates (default `{{ … }}`).
#'
#' @return A character vector of length 1 containing the final prompt.
#' @importFrom RcppTOML parseTOML
#' @importFrom stringi stri_split_fixed stri_trim_both
#' @importFrom stringi stri_detect_regex stri_replace_all_fixed
#' @importFrom stringi stri_match_all_regex
#' @importFrom restorepoint restore.point
#' @export
files2prompt = function(config_file,root_dir = NULL, open = "{", close="}") {
  restore.point("files2prompt")
  if (!file.exists(config_file))
    stop(paste0("config_file ", config_file, " not found."))

  cfg = parseTOML(config_file, escape=FALSE)

  if (is.null(root_dir)) {
    root_dir = cfg[["root_dir"]] %||% "."
  }
  cat(paste0("\nCreate prompt for files in ", normalizePath(root_dir), " based on ", basename(config_file), ".\n"))

  subgroup_names = names(cfg)[sapply(cfg, is.list)]

  #main_files = fp_find_group_files(cfg, root_dir)
  subgroups = lapply(subgroup_names, function(g) cfg[[g]][[1]])
  names(subgroups) = subgroup_names
  .main = cfg[setdiff(names(cfg), subgroup_names)]
  .main$template = .main$template %||% fp_default_template()
  .main$file_template  = .main$file_template  %||% fp_default_file_template()

  groups = c(subgroups, list(.main=.main))
  # Find files for each group
  # Omit duplicated files: every file will be shown only once
  # groups that are specified earlier in the spec have precedence
  all_files = NULL
  g = ".main"
  for (g in names(groups)) {
    files = fp_find_group_files(groups[[g]],root_dir=root_dir)
    groups[[g]]$.files = setdiff(files, all_files)
    all_files = union(all_files, files)
  }
  cat("\nWill add ", NROW(all_files), " files to prompt.\n")


  main_tpl = .main$template

  i = length(groups)
  prompts = sapply(seq_along(groups), function(i) {
    group = groups[[i]]
    if (length(group$.files)==0) return(NULL)
    name = names(groups)[[i]]
    values = c(group, .main[setdiff(names(.main), names(group))])
    file_tpl = group$file_template
    if (is.null(file_tpl)) file_tpl = .main$file_template
    values$filetext = sapply(group$.files, fp_filetext, group=group)
    # short file name
    values$filename = basename(group$.files)
    files_prompt = paste0(tpl_replace_whisker(file_tpl,values), collapse="\n")
    if (is.null(group$template) | name==".main") {
      return(files_prompt)
    } else {
      values$files = files_prompt
      res = tpl_replace_whisker(group$template,values)
      return(res)
    }
  })


  # Make main prompt
  tpl_vars = tpl_vars(main_tpl)

  is_sep_group = names(groups) %in% tpl_vars
  values = .main
  values$files = paste0(unlist(prompts[!is_sep_group]), collapse="\n")
  values[names(groups[is_sep_group])] = prompts[is_sep_group]

  main_prompt = tpl_replace_whisker(main_tpl, values)
  main_prompt
}

#' Heuristic token counter
#'
#' Very rough estimate: _1 token ≈ `bytes_per_token` bytes_.
#' Useful when the Python *tiktoken* library is not available.
#'
#' @param text            Character string to measure.
#' @param bytes_per_token Average bytes per token (default 4 — conservative).
#'
#' @return Integer token count.
#' @export
guess_token_num = function(txt, bytes_per_token=4) {
  ceiling(nchar(txt, type = "bytes") / bytes_per_token)
}

file_pattern_to_regex = function(str) {
  restore.point("file_pattern_to_regex")
  if (length(str)==0) return(NULL)
  vec = stri_split_fixed(str, "\n")[[1]]
  vec = vec[nchar(stri_trim_both(vec))>0]
  if (NROW(vec)==0) return(NULL)
  paste0('(', glob2rx(vec),')', collapse="|")
}

fp_filetext = function(file_path, group, verbose=TRUE) {
  if (verbose) {
    cat(paste0("Add ", basename(file_path), "\n"))
  }
  paste0(readLines(file_path, warn=FALSE), collapse="\n")
}

group_root_dir = function(group, root_dir = ".") {
  group[["root_dir"]] %||% "."
}

fp_find_group_files = function(group, root_dir = ".") {
  restore.point("fp_find_files")
  inc = file_pattern_to_regex(group[["include_files"]])
  # If files_include specified: return no files
  # this makes sense in TOML spec that include files
  # only in subgroups
  if (length(inc)==0) return(NULL)
  exc = file_pattern_to_regex(group[["exclude_files"]])
  root_dir = group_root_dir(group, root_dir)

  files = list.files(root_dir, recursive = TRUE,full.names = FALSE,include.dirs = FALSE)
  full_files = list.files(root_dir, recursive = TRUE,full.names = TRUE,include.dirs = FALSE)

  if (length(inc)>0) {
    keep = stri_detect_regex(files, inc)
    files = files[keep]
    full_files = full_files[keep]
  }
  if (length(exc)>0) {
    ignore = stri_detect_regex(files, exc)
    files = files[!ignore]
    full_files = full_files[!ignore]
  }

  names(full_files) = files
  full_files
}

fp_default_template = function() {
"
{{files}}
"
}

fp_default_file_template = function() {
"
{{files}}
"
}

`%||%` <- function(x, y) {
  if (is.null(x)) y else x
}
```
# END OF FILE: f2p.R

-----------------------------------------------------------


# FILE: tpl.R
```
tpl_replace_whisker = function(txt, values, open = "{{", close = "}}", require_all_value=FALSE) {
  restore.point("tpl_replace_whisker")
  # Define regex with a capturing group for content inside {{ }}
  pattern = tpl_var_pattern(open, close)

  # Locate positions of all matches in the string
  matches <- stri_match_all_regex(txt, pattern,omit_no_match = TRUE)[[1]]
  if (NROW(matches)==0) return(txt)

  symbols = unique(matches[,2])

  null_inds = which(sapply(values, is.null))
  values[null_inds] = as.list(rep("",length(null_inds)))

  vars = names(values)

  missing = setdiff(symbols, vars)
  if (length(missing)>0 & require_all_value) {
    stop("The whisker symbols ", paste0(missing, collapse=", "), " are not in values.")
  } else if (length(missing) >0) {
    symbols = intersect(symbols, vars)
  }
  if (length(symbols)==0) return(txt)

  values = values[symbols]
  whiskers =  paste0(open, symbols,close)


  val_len = sapply(values, length)
  is_one = val_len <= 1


  one_vals = unlist(values[is_one])
  # Replace all occurrences simultaneously using fixed replacement
  if (length(one_vals)>0) {
    txt <- stri_replace_all_fixed(txt, whiskers[is_one], one_vals, vectorize_all = FALSE)

  }

  # values that are vectors
  # loop through all values
  inds = which(!is_one)
  i = 1
  for (i in inds) {
    txt <- stri_replace_all_fixed(txt, whiskers[i], values[[i]], vectorize_all = TRUE)
  }

  txt
}


example = function() {
  tpl = "Hi {{name}}!"
  escape_regex(c("{{","{[]}"))
}

escape_regex <- function(patterns) {
  stringi::stri_replace_all_regex(
    patterns,
    "([\\\\\\^\\$\\.\\*\\+\\?\\(\\)\\[\\]\\{\\}\\|])",
    "\\\\$1"
  )
}

tpl_var_pattern = function(open = "{{", close = "}}") {
  open = escape_regex(open)
  close = escape_regex(close)
  pattern <- paste0(open,"\\s*(.*?)\\s*", close)
}

tpl_vars = function(txt, open = "{{", close = "}}") {
  pattern = tpl_var_pattern(open, close)
  #pattern <- "\\{\\{\\s*(.*?)\\s*\\}\\}"
  vars <- unique(stri_match_all_regex(txt, pattern)[[1]][,2])
  vars
}
```
# END OF FILE: tpl.R

-----------------------------------------------------------


```md
# files2prompt

Turn a folder full of code and text files into a single prompt string. Has an RStudio Addin and can be customized using **TOML** specs.

---

## Installation (r‑universe)
```r
install.packages(
  "files2prompt",
  repos = c("https://skranz.r-universe.dev", getOption("repos"))
)
```
Or directly from Github:

```
remotes::install_github("skranz/files2prompt")
```
---

## 1. Usage & RStudio Add‑in (default specs)

1. Open your project in RStudio.
2. **Addins ▸ FILES2PROMPT ▸ Files To Prompt** → the add‑in will
   * build the prompt containing the content of the code files of your R project
     using a default spec or custom spec (see below) 
   * save it as **`files2prompt.txt`** in the project directory (or working directory)
   * open the file in a new tab, select all text, **and**
   * copy it to your clipboard (if the optional **clipr** package is installed).

3. You can then copy & paste it to an LLM interface and possibly manually adapt


## 2. Custom specs

### 2.1 A first custom spec

You can customize the prompt generation and also use the package programmatically. Customiztaion use based on [TOML](https://toml.io/en/) specifications. To get started, you can create a simple config file called **`f2p_my_spec.toml`** in your project root:

```toml
include_files = '''
*.R         
*.Rmd
'''

# E.g. exclude some Rmd that your file convention 
# marks as old versions
exclude_files = '''
*_old.Rmd
'''

```

This will paste every R and Rmd file (unless those marked in exclude_files) into the prompt. If you now call the Addin **Files To Prompt** it will by default use the first file matching the glob `f2p_*.toml` in the project folder as specification to build the prompt. If no R project is open it will search the working directory. 

The root_directory to search for R files is the project directory or working directory, respectively.

### 2.2 Using the package in an R script

The `files2prompt` function is the main interface:

```r
library(files2prompt)
prompt = files2prompt(config_file="f2p_my_spec.toml", root_dir = getwd())

cat(prompt) 
guess_token_num(prompt)
```
---

## 2.3 More complex TOML specs

The TOML specs can be customized further. The `inst/toml` folder contains commented examples. You can customize the generated prompts, have different formats for certain file groups etc. 

## 3 Possible extensions

Perhaps adding possibility to add data set files in certain text representations formats...

© 2025 Sebastian Kranz — MIT License

```




#######################################################
# YOUR TASK
#######################################################

Please describe the code base and propose improvements.


